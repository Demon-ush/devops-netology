# Домашнее задание к занятию "6.6. TroubleshootingL"


## Pадача 1
Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.
Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
Вы как инженер поддержки решили произвести данную операцию:
 напишите список операций, которые вы будете производить для остановки запроса пользователя
 предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

### Ответ:
```
Определить текущую операцию командой:
    db.currentOp()
например, исполняющиеся более 10 секунд:
    db.currentOp({"active": true, "secs_running": {"$gt": 10}})
Завершить операцию по opid:
    db.killOp()

Для определения вариантов решения проблем с долгими запросами недостаточно исходных данных. Возможные пути решения в зависимости от ситуации (после анализа причин):
 перестроить (построить при отсутствии) соответствующий индекс (но аккуратно, с учётом всех особенностей индексов MongoDB);  Если необходимый индекс есть, но БД его не использует, попробовать форсировать использование индекса с помощью hint;
 поиграться с запросом и его параметрами;
 поиграться с количеством одновременных запросов, ибо чем больше параллельных запросов, тем медленнее они выполняются;
 рассмотреть вопрос с разделением коллекции на части;
 уменьшить (укоротить) названия полей, т.к длинные названия полей увеличивают размер документов;
 возможно необходимо горизонтальное масштабирование, т.е. шардирование (однако, следует учитывать снижение удельной производительности коллекции в целом и не забыть в запросе индекс для шардирования);
 увеличить ресурсы.

```

## Задача 2
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.
Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.
При масштабировании сервиса до N реплик вы увидели, что:
 сначала рост отношения записанных значений к истекшим
 Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?


### Ответ:
```
Согласно документации «это означает, что, если в базе данных много ключей, срок действия которых истекает в одну секунду, и они составляют не менее 25% от текущей совокупности ключей с истекающим TTL, то Redis может заблокироваться, чтобы получить процент уже истекших ключей ниже 25% ».

```

## Задача 3
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы пользователи начали жаловаться на ошибки вида:
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?
Какие пути решения данной проблемы вы можете предложить?

### Ответ:
```
Прямой ответ и рекомендации по устранению даны в документации MySQL по ссылке:
https://dev.mysql.com/doc/refman/8.0/en/error-lost-connection.html
B.3.2.3 Lost connection to MySQL server

Если коротко изложить суть, то получим следующее (по убыванию вероятности):
1. Сетевые проблемы
Обычно это указывает на неисправность сетевого подключения, и следует проверить состояние сети, если эта ошибка возникает часто. Если сообщение об ошибке содержит “during query”, то с наибольшей вероятностью это искомый случай.
2. Иногда ошибка “during query” возникает, когда миллионы строк отправляются как часть одного или нескольких запросов. Если известно, что это происходит, то необходимо попробовать увеличить net_read_timeout с 30 секунд по умолчанию до 60 секунд или более, подобрав величину достаточную для завершения передачи данных.
3. Реже ошибка возникает в случае, когда клиент пытается установить первоначальное подключение к серверу. В этом случае, если для connect_timeout установлено значение всего в несколько секунд, то проблему можно попробовать решить, увеличив значение параметра до десяти секунд, возможно, больше, если расстояние очень большое или соединение медленное. Определить, возникает ли эта более редкая причина, можно с помощью команды 
SHOW GLOBAL STATUS LIKE 'Aborted_connects'. 
Она увеличивается на единицу для каждой начальной попытки подключения, которую сервер прерывает. “reading authorization packet” может отображаться как часть сообщения об ошибке; если да, это также говорит о том, что это решение, которое необходимо.
4. Если причиной не является ни одна из описанных выше ситуаций, то возможно возникла проблема со значениями BLOB, превышающими max_allowed_packet, что может привести к ошибке Lost connection для некоторых клиентов. Иногда можно увидеть ошибку ER_NET_PACKET_TOO_LARGE, и её наличие подтверждает, что необходимо увеличить значение параметра max_allowed_packet.

```

## Задача 4
Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
postmaster invoked oom-killer
Как вы думаете, что происходит?
Как бы вы решили данную проблему?

### Ответ:
```
OOM-killer убил процесс, сожравший системнуюпамять, во избежание краха системы.

Сообщение dmesg должно дублироваться в логе PostgreSQL чем-то вроде:
    Out of Memory: Killed process 12345 (postgres).

Решаться проблема утечки памяти может 2-мя путями или их комбинацией:
 на уровне системы: параметрами ядра vm.overcommit_memory (в 2-ку) и overcommit_ratio (лимит памяти)
В этом параметре указывается процент памяти, для которого допустимо избыточное резервирование. Если для него нет места, память не выделяется, и в резервировании будет отказано. Это самый безопасный вариант, рекомендованный для PostgreSQL. 
На OOM-Killer влияет еще один элемент — возможность подкачки, которой управляет переменная cat /proc/sys/vm/swappiness. Эти значения указывают ядру, как обрабатывать подкачку страниц. Чем больше значение, тем меньше вероятности, что OOM завершит процесс, но из-за операций ввода-вывода это негативно сказывается на базе данных. И наоборот…
Ещё неплохо прошерстить файлик /etc/security/limits.conf и посмотреть вывод ulimit -a и tail /var/log/audit/audit.log

 на уровне настройки PostgreSQL: shared_buffer, wal_buffers, effective_cache_size, work_mem, maintenance_work_mem, synchronous_commit, checkpoint_timeout, checkpoint_completion_target.

```



